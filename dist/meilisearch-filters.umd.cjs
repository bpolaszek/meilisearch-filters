(function(s,r){typeof exports=="object"&&typeof module<"u"?r(exports):typeof define=="function"&&define.amd?define(["exports"],r):(s=typeof globalThis<"u"?globalThis:s||self,r(s["meilisearch-filters"]={}))})(this,function(s){"use strict";var C=Object.defineProperty;var W=(s,r,u)=>r in s?C(s,r,{enumerable:!0,configurable:!0,writable:!0,value:u}):s[r]=u;var l=(s,r,u)=>(W(s,typeof r!="symbol"?r+"":r,u),u);const r=n=>`'${`${n}`.replace(/[\\"']/g,"\\$&").replace(/\u0000/g,"\\0")}'`;class u extends Error{constructor(e,...t){super(...t),this.name="UnhandledMatchError",this.message=`Unhandled match value of type ${typeof e} - ${e}`,Error.captureStackTrace(this,u)}}const c=Symbol(),p=(n,e)=>{const t=new Map;for(const[...i]of e){const M=i.pop();for(const m of i.flat())t.has(m)||t.set(m,M)}if(!t.has(n)&&!t.has(c))throw new u(n);return t.get(n)??t.get(c)};p.default=c;class o{toString(){throw new Error("This method has to be implemented.")}and(e){return e instanceof h&&(e=e.group()),new B([this,e])}or(e){return e instanceof h&&(e=e.group()),new N([this,e])}negate(){return new $(this)}group(){return new w(this)}}class T extends o{toString(){return""}and(e){return e}or(e){return e}negate(){throw new Error("An empty expression cannot be negated.")}group(){return this}}class h extends o{}class w extends o{constructor(e){super(),this.expression=e}toString(){return`(${this.expression})`}group(){return this}}class $ extends o{constructor(e){super(),this.expression=e}toString(){return`NOT ${this.expression}`}}class B extends h{constructor(e){super(),this.expressions=e}negate(){return this.group().negate()}toString(){return this.expressions.join(" AND ")}}class N extends h{constructor(e){super(),this.expressions=e}negate(){return this.group().negate()}toString(){return this.expressions.join(" OR ")}}class a extends o{constructor(e,t,i="="){super(),this.field=e,this.value=t,this.operator=i}negate(){const e=new a(this.field,this.value);return e.operator=p(this.operator,[["=","!="],["!=","="],[">","<="],["<",">="],[">=","<"],["<=",">"]]),e}toString(){return`${this.field} ${this.operator} ${r(this.value)}`}}class E extends o{constructor(e,t,i){super(),this.field=e,this.left=t,this.right=i}toString(){return`${this.field} ${r(this.left)} TO ${r(this.right)}`}}class g extends o{constructor(t){super();l(this,"negated",!1);this.field=t}negate(){const t=new g(this.field);return t.negated=!this.negated,t}toString(){return this.negated?`${this.field} NOT EXISTS`:`${this.field} EXISTS`}}class d extends o{constructor(t,i){super();l(this,"negated",!1);this.field=t,this.type=i}negate(){const t=new d(this.field,this.type);return t.negated=!this.negated,t}toString(){return this.negated?`${this.field} IS NOT ${this.type}`:`${this.field} IS ${this.type}`}}class f extends o{constructor(t,i){super();l(this,"negated",!1);this.field=t,this.values=i}negate(){const t=new f(this.field,this.values);return t.negated=!this.negated,t}toString(){const t=this.values.map(r);return this.negated?`${this.field} NOT IN [${t.join(", ")}]`:`${this.field} IN [${t.join(", ")}]`}}class y extends o{constructor(e,t,i){super(),this.latitude=e,this.longitude=t,this.distanceInMeters=i}toString(){return`_geoRadius(${this.latitude}, ${this.longitude}, ${this.distanceInMeters})`}}class G extends o{constructor(e,t){super(),this.topLeftCorner=e,this.bottomRightCorner=t}toString(){return`_geoBoundingBox(${[this.topLeftCorner,this.bottomRightCorner].map(([t,i])=>`[${t}, ${i}]`).join(", ")})`}}class I{constructor(e){this.field=e}equals(e){return new a(this.field,e)}notEquals(e){return this.equals(e).negate()}isGreaterThan(e,t=!1){return new a(this.field,e,t?">=":">")}isNotGreaterThan(e,t=!1){return this.isGreaterThan(e,t).negate()}isLowerThan(e,t=!1){return new a(this.field,e,t?"<=":"<")}isNotLowerThan(e,t=!1){return this.isLowerThan(e,t).negate()}isBetween(e,t,i=!0){return i?new E(this.field,e,t):this.isGreaterThan(e).and(this.isLowerThan(t))}isNotBetween(e,t,i=!0){return this.isBetween(e,t,i).negate()}exists(){return new g(this.field)}doesNotExist(){return this.exists().negate()}isNull(){return new d(this.field,"NULL")}isNotNull(){return this.isNull().negate()}isEmpty(){return new d(this.field,"EMPTY")}isNotEmpty(){return this.isEmpty().negate()}isIn(e){return new f(this.field,e)}isNotIn(e){return this.isIn(e).negate()}}const b=(...n)=>{let e=new T;for(const t of n)e=e.and(t);return e},R=n=>new I(n),v=n=>new $(n),L=n=>new w(n);function x(n,e,t){return new y(n,e,t)}function O(n,e,t){return x(n,e,t).negate()}function S(n,e){return new G(n,e)}function j(n,e){return S(n,e).negate()}s.field=R,s.filterBuilder=b,s.group=L,s.not=v,s.notWithinGeoBoundingBox=j,s.notWithinGeoRadius=O,s.withinGeoBoundingBox=S,s.withinGeoRadius=x,Object.defineProperty(s,Symbol.toStringTag,{value:"Module"})});
