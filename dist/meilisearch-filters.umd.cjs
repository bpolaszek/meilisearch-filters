(function(s,i){typeof exports=="object"&&typeof module<"u"?i(exports):typeof define=="function"&&define.amd?define(["exports"],i):(s=typeof globalThis<"u"?globalThis:s||self,i(s["meilisearch-filters"]={}))})(this,function(s){"use strict";var F=Object.defineProperty;var P=(s,i,o)=>i in s?F(s,i,{enumerable:!0,configurable:!0,writable:!0,value:o}):s[i]=o;var a=(s,i,o)=>(P(s,typeof i!="symbol"?i+"":i,o),o);const i=n=>`'${`${n}`.replace(/[\\"']/g,"\\$&").replace(/\u0000/g,"\\0")}'`;class o extends Error{constructor(t,...e){super(...e),this.name="UnhandledMatchError",this.message=`Unhandled match value of type ${typeof t} - ${t}`,Error.captureStackTrace(this,o)}}const p=Symbol(),B=(n,t)=>{const e=new Map;for(const[...r]of t){const U=r.pop();for(const I of r.flat())e.has(I)||e.set(I,U)}if(!e.has(n)&&!e.has(p))throw new o(n);return e.get(n)??e.get(p)};B.default=p;const h=n=>typeof n=="string"?S.fromString(n):n,c=n=>n.map(h),w=n=>n.filter(t=>!(t instanceof $));class u{toString(){throw new Error("This method has to be implemented.")}and(t,...e){return e=w(c([this,t,...e])),e.length>0?new m(e):this}or(t,...e){return e=w(c([this,t,...e])),e.length>0?new b(e):this}negate(){return new N(this)}group(){return new E(this)}static create(...t){if(t=w(c(t)),t.length===0)return new $;const e=t.shift();return t.length>0?e.and(...t):e}}class $ extends u{toString(){return""}and(t,...e){return e.length===0?h(t):super.and(t,...e)}or(t,...e){return e.length===0?h(t):super.or(t,...e)}negate(){return this}group(){return this}}class S extends u{constructor(t){super(),this.expression=t}toString(){return this.expression}static fromString(t){return t.length>0?new S(t):new $}}class g extends u{constructor(e){super();a(this,"expressions");this.expressions=c(e).map(r=>r instanceof g?r.group():r)}negate(){return this.group().negate()}}class m extends g{constructor(t){super(t)}toString(){return this.expressions.join(" AND ")}}class b extends g{constructor(t){super(t)}toString(){return this.expressions.join(" OR ")}}class E extends u{constructor(e){super();a(this,"expression");this.expression=h(e)}toString(){return`(${this.expression})`}group(){return this}}class N extends u{constructor(e){super();a(this,"expression");this.expression=h(e)}and(e,...r){return this.group().and(e,...r)}or(e,...r){return this.group().or(e,...r)}negate(){return this.expression}toString(){return`NOT ${this.expression}`}}class l extends u{constructor(t){super(),this.field=t}}class d extends l{constructor(t,e,r="="){super(t),this.value=e,this.operator=r}negate(){const t=new d(this.field,this.value);return t.operator=B(this.operator,[["=","!="],["!=","="],[">","<="],["<",">="],[">=","<"],["<=",">"]]),t}toString(){return`${this.field} ${this.operator} ${i(this.value)}`}}class v extends l{constructor(t,e,r){super(t),this.left=e,this.right=r}toString(){return`${this.field} ${i(this.left)} TO ${i(this.right)}`}}class T extends l{constructor(e){super(e);a(this,"negated",!1)}negate(){const e=new T(this.field);return e.negated=!this.negated,e}toString(){return this.negated?`${this.field} NOT EXISTS`:`${this.field} EXISTS`}}class f extends l{constructor(e,r){super(e);a(this,"negated",!1);this.type=r}negate(){const e=new f(this.field,this.type);return e.negated=!this.negated,e}toString(){return this.negated?`${this.field} IS NOT ${this.type}`:`${this.field} IS ${this.type}`}}class x extends l{constructor(e,r){super(e);a(this,"negated",!1);this.values=r}negate(){const e=new x(this.field,this.values);return e.negated=!this.negated,e}toString(){const e=this.values.map(i);return this.negated?`${this.field} NOT IN [${e.join(", ")}]`:`${this.field} IN [${e.join(", ")}]`}}class R extends u{constructor(t,e,r){super(),this.latitude=t,this.longitude=e,this.distanceInMeters=r}toString(){return`_geoRadius(${this.latitude}, ${this.longitude}, ${this.distanceInMeters})`}}class L extends u{constructor(t,e){super(),this.topLeftCorner=t,this.bottomRightCorner=e}toString(){return`_geoBoundingBox(${[this.topLeftCorner,this.bottomRightCorner].map(([e,r])=>`[${e}, ${r}]`).join(", ")})`}}class O{constructor(t){this.field=t}equals(t){return new d(this.field,t)}notEquals(t){return this.equals(t).negate()}isGreaterThan(t,e=!1){return new d(this.field,t,e?">=":">")}isNotGreaterThan(t,e=!1){return this.isGreaterThan(t,e).negate()}isLowerThan(t,e=!1){return new d(this.field,t,e?"<=":"<")}isNotLowerThan(t,e=!1){return this.isLowerThan(t,e).negate()}isBetween(t,e,r=!0){return r?new v(this.field,t,e):this.isGreaterThan(t).and(this.isLowerThan(e))}isNotBetween(t,e,r=!0){return this.isBetween(t,e,r).negate()}exists(){return new T(this.field)}doesNotExist(){return this.exists().negate()}isNull(){return new f(this.field,"NULL")}isNotNull(){return this.isNull().negate()}isEmpty(){return new f(this.field,"EMPTY")}isNotEmpty(){return this.isEmpty().negate()}isIn(t){return new x(this.field,t)}isNotIn(t){return this.isIn(t).negate()}hasAll(t){return new m(t.map(e=>this.equals(e)))}hasNone(t){return this.hasAll(t).negate()}}const j=(...n)=>u.create(...n),M=n=>new O(n),q=n=>new N(n),A=(n,...t)=>t.length===0?new E(n):new m([n,...t]).group();function y(n,t,e){return new R(n,t,e)}function C(n,t,e){return y(n,t,e).negate()}function G(n,t){return new L(n,t)}function W(n,t){return G(n,t).negate()}s.field=M,s.filterBuilder=j,s.group=A,s.not=q,s.notWithinGeoBoundingBox=W,s.notWithinGeoRadius=C,s.withinGeoBoundingBox=G,s.withinGeoRadius=y,Object.defineProperty(s,Symbol.toStringTag,{value:"Module"})});
