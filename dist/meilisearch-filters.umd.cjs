(function(r,i){typeof exports=="object"&&typeof module<"u"?i(exports):typeof define=="function"&&define.amd?define(["exports"],i):(r=typeof globalThis<"u"?globalThis:r||self,i(r["meilisearch-filters"]={}))})(this,function(r){"use strict";var U=Object.defineProperty;var P=(r,i,u)=>i in r?U(r,i,{enumerable:!0,configurable:!0,writable:!0,value:u}):r[i]=u;var a=(r,i,u)=>(P(r,typeof i!="symbol"?i+"":i,u),u);const i=n=>`'${`${n}`.replace(/[\\"']/g,"\\$&").replace(/\u0000/g,"\\0")}'`;class u extends Error{constructor(t,...e){super(...e),this.name="UnhandledMatchError",this.message=`Unhandled match value of type ${typeof t} - ${t}`,Error.captureStackTrace(this,u)}}const w=Symbol(),B=(n,t)=>{const e=new Map;for(const[...s]of t){const W=s.pop();for(const b of s.flat())e.has(b)||e.set(b,W)}if(!e.has(n)&&!e.has(w))throw new u(n);return e.get(n)??e.get(w)};B.default=w;const l=n=>typeof n=="string"?m.fromString(n):n,g=n=>n.map(l),$=n=>n.filter(t=>!(t instanceof f));class o{toString(){throw new Error("This method has to be implemented.")}and(t,...e){return e=$(g([this,t,...e])),e.length>0?new S(e):this}or(t,...e){return e=$(g([this,t,...e])),e.length>0?new v(e):this}negate(){return new x(this)}group(){return new N(this)}static create(...t){if(t=$(g(t)),t.length===0)return new f;const e=t.shift();return t.length>0?e.and(...t):e}}class f extends o{toString(){return""}and(t,...e){return e.length===0?l(t):super.and(t,...e)}or(t,...e){return e.length===0?l(t):super.or(t,...e)}negate(){return this}group(){return this}}class m extends o{constructor(t){super(),this.expression=t}toString(){return this.expression}static fromString(t){return t.length>0?new m(t):new f}}class d extends o{constructor(e){super();a(this,"expressions");this.expressions=g(e).map(s=>s instanceof d?s.group():s)}negate(){return this.group().negate()}}class S extends d{constructor(t){super(t)}toString(){return this.expressions.join(" AND ")}}class v extends d{constructor(t){super(t)}toString(){return this.expressions.join(" OR ")}}class N extends o{constructor(e){super();a(this,"expression");this.expression=l(e)}toString(){return`(${this.expression})`}group(){return this}}class x extends o{constructor(e){super();a(this,"expression");this.expression=l(e)}and(e,...s){return this.group().and(e,...s)}or(e,...s){return this.group().or(e,...s)}negate(){return this.expression}toString(){return`NOT ${this.expression}`}}class h extends o{constructor(t){super(),this.field=t}}class c extends h{constructor(t,e,s="="){super(t),this.value=e,this.operator=s}negate(){const t=new c(this.field,this.value);return t.operator=B(this.operator,[["=","!="],["!=","="],[">","<="],["<",">="],[">=","<"],["<=",">"]]),t}toString(){return`${this.field} ${this.operator} ${i(this.value)}`}}class R extends h{constructor(t,e,s){super(t),this.left=e,this.right=s}toString(){return`${this.field} ${i(this.left)} TO ${i(this.right)}`}}class E extends h{constructor(e){super(e);a(this,"negated",!1)}negate(){const e=new E(this.field);return e.negated=!this.negated,e}toString(){return this.negated?`${this.field} NOT EXISTS`:`${this.field} EXISTS`}}class p extends h{constructor(e,s){super(e);a(this,"negated",!1);this.type=s}negate(){const e=new p(this.field,this.type);return e.negated=!this.negated,e}toString(){return this.negated?`${this.field} IS NOT ${this.type}`:`${this.field} IS ${this.type}`}}class T extends h{constructor(e,s){super(e);a(this,"negated",!1);this.values=s}negate(){const e=new T(this.field,this.values);return e.negated=!this.negated,e}toString(){const e=this.values.map(i);return this.negated?`${this.field} NOT IN [${e.join(", ")}]`:`${this.field} IN [${e.join(", ")}]`}}class L extends o{constructor(t,e,s){super(),this.latitude=t,this.longitude=e,this.distanceInMeters=s}toString(){return`_geoRadius(${this.latitude}, ${this.longitude}, ${this.distanceInMeters})`}}class O extends o{constructor(t,e){super(),this.topLeftCorner=t,this.bottomRightCorner=e}toString(){return`_geoBoundingBox(${[this.topLeftCorner,this.bottomRightCorner].map(([e,s])=>`[${e}, ${s}]`).join(", ")})`}}class y{constructor(t){this.field=t}equals(t){return new c(this.field,t)}notEquals(t){return this.equals(t).negate()}isGreaterThan(t,e=!1){return new c(this.field,t,e?">=":">")}isNotGreaterThan(t,e=!1){return this.isGreaterThan(t,e).negate()}isLowerThan(t,e=!1){return new c(this.field,t,e?"<=":"<")}isNotLowerThan(t,e=!1){return this.isLowerThan(t,e).negate()}isBetween(t,e,s=!0){return s?new R(this.field,t,e):this.isGreaterThan(t).and(this.isLowerThan(e))}isNotBetween(t,e,s=!0){return this.isBetween(t,e,s).negate()}exists(){return new E(this.field)}doesNotExist(){return this.exists().negate()}isNull(){return new p(this.field,"NULL")}isNotNull(){return this.isNull().negate()}isEmpty(){return new p(this.field,"EMPTY")}isNotEmpty(){return this.isEmpty().negate()}isIn(t){return new T(this.field,t)}isNotIn(t){return this.isIn(t).negate()}hasAll(t){return new S(t.map(e=>this.equals(e)))}hasNone(t){return this.hasAll(t).negate()}}const j=(...n)=>o.create(...n),M=n=>new y(n),C=n=>new x(n),q=(n,...t)=>t.length===0?new N(n):new S([n,...t]).group();function G(n,t,e){return new L(n,t,e)}function A(n,t,e){return G(n,t,e).negate()}function I(n,t){return new O(n,t)}function F(n,t){return I(n,t).negate()}r.CompositeExpression=d,r.EmptyExpression=f,r.Expression=o,r.Field=y,r.FieldExpression=h,r.field=M,r.filterBuilder=j,r.group=q,r.not=C,r.notWithinGeoBoundingBox=F,r.notWithinGeoRadius=A,r.withinGeoBoundingBox=I,r.withinGeoRadius=G,Object.defineProperty(r,Symbol.toStringTag,{value:"Module"})});
