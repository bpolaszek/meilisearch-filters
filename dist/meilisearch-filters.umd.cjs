(function(s,i){typeof exports=="object"&&typeof module<"u"?i(exports):typeof define=="function"&&define.amd?define(["exports"],i):(s=typeof globalThis<"u"?globalThis:s||self,i(s["meilisearch-filters"]={}))})(this,function(s){"use strict";var C=Object.defineProperty;var q=(s,i,o)=>i in s?C(s,i,{enumerable:!0,configurable:!0,writable:!0,value:o}):s[i]=o;var c=(s,i,o)=>(q(s,typeof i!="symbol"?i+"":i,o),o);const i=n=>`'${`${n}`.replace(/[\\"']/g,"\\$&").replace(/\u0000/g,"\\0")}'`;class o extends Error{constructor(e,...t){super(...t),this.name="UnhandledMatchError",this.message=`Unhandled match value of type ${typeof e} - ${e}`,Error.captureStackTrace(this,o)}}const g=Symbol(),$=(n,e)=>{const t=new Map;for(const[...r]of e){const A=r.pop();for(const B of r.flat())t.has(B)||t.set(B,A)}if(!t.has(n)&&!t.has(g))throw new o(n);return t.get(n)??t.get(g)};$.default=g;class u{toString(){throw new Error("This method has to be implemented.")}and(e){return e instanceof d&&(e=e.group()),new f([this,e])}or(e){return e instanceof d&&(e=e.group()),new E([this,e])}negate(){return new S(this)}group(){return new x(this)}}class N extends u{toString(){return""}and(e){return e}or(e){return e}negate(){throw new Error("An empty expression cannot be negated.")}group(){return this}}class d extends u{}class a extends u{constructor(e){super(),this.field=e}}class x extends u{constructor(e){super(),this.expression=e}toString(){return`(${this.expression})`}group(){return this}}class S extends u{constructor(e){super(),this.expression=e}and(e){return this.group().and(e)}or(e){return this.group().or(e)}negate(){return this.expression}toString(){return`NOT ${this.expression}`}}class f extends d{constructor(e){super(),this.expressions=e}negate(){return this.group().negate()}toString(){return this.expressions.join(" AND ")}}class E extends d{constructor(e){super(),this.expressions=e}negate(){return this.group().negate()}toString(){return this.expressions.join(" OR ")}}class h extends a{constructor(e,t,r="="){super(e),this.value=t,this.operator=r}negate(){const e=new h(this.field,this.value);return e.operator=$(this.operator,[["=","!="],["!=","="],[">","<="],["<",">="],[">=","<"],["<=",">"]]),e}toString(){return`${this.field} ${this.operator} ${i(this.value)}`}}class y extends a{constructor(e,t,r){super(e),this.left=t,this.right=r}toString(){return`${this.field} ${i(this.left)} TO ${i(this.right)}`}}class p extends a{constructor(t){super(t);c(this,"negated",!1)}negate(){const t=new p(this.field);return t.negated=!this.negated,t}toString(){return this.negated?`${this.field} NOT EXISTS`:`${this.field} EXISTS`}}class l extends a{constructor(t,r){super(t);c(this,"negated",!1);this.type=r}negate(){const t=new l(this.field,this.type);return t.negated=!this.negated,t}toString(){return this.negated?`${this.field} IS NOT ${this.type}`:`${this.field} IS ${this.type}`}}class w extends a{constructor(t,r){super(t);c(this,"negated",!1);this.values=r}negate(){const t=new w(this.field,this.values);return t.negated=!this.negated,t}toString(){const t=this.values.map(i);return this.negated?`${this.field} NOT IN [${t.join(", ")}]`:`${this.field} IN [${t.join(", ")}]`}}class G extends u{constructor(e,t,r){super(),this.latitude=e,this.longitude=t,this.distanceInMeters=r}toString(){return`_geoRadius(${this.latitude}, ${this.longitude}, ${this.distanceInMeters})`}}class I extends u{constructor(e,t){super(),this.topLeftCorner=e,this.bottomRightCorner=t}toString(){return`_geoBoundingBox(${[this.topLeftCorner,this.bottomRightCorner].map(([t,r])=>`[${t}, ${r}]`).join(", ")})`}}class b{constructor(e){this.field=e}equals(e){return new h(this.field,e)}notEquals(e){return this.equals(e).negate()}isGreaterThan(e,t=!1){return new h(this.field,e,t?">=":">")}isNotGreaterThan(e,t=!1){return this.isGreaterThan(e,t).negate()}isLowerThan(e,t=!1){return new h(this.field,e,t?"<=":"<")}isNotLowerThan(e,t=!1){return this.isLowerThan(e,t).negate()}isBetween(e,t,r=!0){return r?new y(this.field,e,t):this.isGreaterThan(e).and(this.isLowerThan(t))}isNotBetween(e,t,r=!0){return this.isBetween(e,t,r).negate()}exists(){return new p(this.field)}doesNotExist(){return this.exists().negate()}isNull(){return new l(this.field,"NULL")}isNotNull(){return this.isNull().negate()}isEmpty(){return new l(this.field,"EMPTY")}isNotEmpty(){return this.isEmpty().negate()}isIn(e){return new w(this.field,e)}isNotIn(e){return this.isIn(e).negate()}hasAll(e){return new f(e.map(t=>this.equals(t)))}hasNone(e){return this.hasAll(e).negate()}}const R=(...n)=>n.length===0?new N:new f(n),v=n=>new b(n),L=n=>new S(n),O=n=>new x(n);function m(n,e,t){return new G(n,e,t)}function j(n,e,t){return m(n,e,t).negate()}function T(n,e){return new I(n,e)}function M(n,e){return T(n,e).negate()}s.field=v,s.filterBuilder=R,s.group=O,s.not=L,s.notWithinGeoBoundingBox=M,s.notWithinGeoRadius=j,s.withinGeoBoundingBox=T,s.withinGeoRadius=m,Object.defineProperty(s,Symbol.toStringTag,{value:"Module"})});
